// Shift JIS

global proc createCatToolWindow() {
    if((`window -ex CatToolWindow`) == true) deleteUI CatToolWindow;
    string $win = `window CatToolWindow`;
    scrollLayout;
    columnLayout -adj true;
    
    rowLayout -nc 2;
    text -l "???ÑÖp?[?c?J?n?W???C???g";
    textField RITAI_FIELD;
    setParent ..;
    
    rowLayout -nc 2;
    text -l "?I???W???C???g?i???????????????j";
    textField RITAI_LAST_FIELD;
    setParent ..;
    
    rowLayout -nc 2;
    text -l "?p?X??J?[?u";
    textField -tx "trackPathCurve" PATHCURVE_FIELD;
    setParent ..;
    
    rowLayout -nc 3;
    text -l "?n?`";
    textField TERRAIN_FIELD;
    button -l "set" -c "setSelectedObjectToField(\"terrain_field\")";
    setParent ..;
    
    gridLayout -nc 3 -cw 150;
    
    button -w 120 -l "???ÑÑ??J????????èÔ" -c "getLoopCountFromTextfield";
    button -w 120 -l "???ÑÑ??R?s?[?E?????" -c "duplicateCaterpillerFromUI";
    checkBox -l "X????" TRACK_LOOP_DIRECTION_CHECKBOX;
    button -l "?X?v???C??IK???" -c "attachIKsprineHandleToCurve";
    button -l "???[?V?????p?X??A?^?b?`" -c "attachPathAnimationToCurve";
    button -l "?n?`??????" -c "createTerrainRoughness(0.5)";
    setParent ..;
    
    separator;
    
    rowLayout -nc 3;
    text -l "?]???s?{?b?g????I?u?W?F?N?g";
    textField WHEEL1_FIELD;
    button -l "?I???I?u?W?F?N?g???Z?b?g" -c "setSelectedObjectToField(\"wheel1_field\")";
    setParent ..;
    
    rowLayout -nc 2;
    text -l "???a";
    textField -tx "3" WHEEL_RADIUS_FIELD; 
    setParent ..;
    rowLayout -nc 2;
    
    text -l "???????a";
    textField -tx "0.666" DRIVE_WHEEL_RADIUS_FIELD;
    setParent ..;
    
    
    rowLayout -nc 3;
    text -l "movableWheels";
    textField WHEELS_FIELD;
    button -l "?I???I?u?W?F?N?g???Z?b?g" -c "setSelectedObjectToField(\"WHEELS_FIELD\")";
    setParent ..;
    
    rowLayout -nc 3;
    text -l "???????";
    textField DRIVE_WHEELS_FIELD;
    button -l "?I???I?u?W?F?N?g???Z?b?g" -c "setSelectedObjectToField(\"DRIVE_WHEELS_FIELD\")";
    setParent ..;
    rowLayout -nc 3;
    text -l "???????";
    textField FIXED_WHEELS_FIELD;
    button -l "?I???I?u?W?F?N?g???Z?b?g" -c "setSelectedObjectToField(\"FIXED_WHEELS_FIELD\")";
    setParent ..;
    
    button -l "????_???o??" -c "getTerrainPointUnderWheel";
    
    button -l "????????????" -c "landWheelOnGround";
    
    button -l "?????????????" -c "adjustIkOnTerrain";
    
    button -l "adjust MovableWheels Height" -c "adjustMovableWheelsOnTerrain";
    button -l "?]???p?X????????" -c "editPathCurveFromWheels";
    button -l "?J?[?u??????????????r???h????" -c "rebuildPathCurve";
    button -l "?J?[?u????ÑÑ????" -c "alignPathAndTrack";
    button -l "KeyWheels" -c "setKeyWheels";
    setParent ..;
           
    showWindow $win;
}

// ?I???W???C???g?e?L?X?g?t?B?[???h???X?V
proc string setLastJointField(string $str){
    return `textField -e -tx $str RITAI_LAST_FIELD`;
}
// ?I???W???C???g?e?L?X?g?t?B?[???h????e???èÔ
proc string getLastJointField(){
    return `textField -q -tx RITAI_LAST_FIELD`;
}
proc string getFirstJointField(){
    return `textField -q -tx RITAI_FIELD`;
}


// ?I???I?u?W?F?N?g???e?L?X?g?t?B?[???h??Z?b?g
proc setSelectedObjectToField(string $field){
    $sel = `ls -sl`;
    string $list[] = `ls -sl`;
    string $selList = stringArrayToString($list, ", ");
    print($list);
    switch($field){
        case "wheel1_field":
            textField -e -tx $sel WHEEL1_FIELD;
            break;
        case "terrain_field":
            textField -e -tx $sel TERRAIN_FIELD;
            break;
        case "WHEELS_FIELD":
            textField -e -tx $selList WHEELS_FIELD;
            break;
        case "DRIVE_WHEELS_FIELD":
            textField -e -tx $selList DRIVE_WHEELS_FIELD;
            break;
        case "FIXED_WHEELS_FIELD":
            textField -e -tx $selList FIXED_WHEELS_FIELD;
            break;
        
    }
}

// ?e?L?X?g?t?B?[???h??J???}?????L??????I?u?W?F?N?g??z????????
proc string[] getTextFieldObjects(string $text){
    string $array[];
    tokenize($text, ", ", $array);
    string $result[];
    for($a in $array){
        if($a == "" || $a == " ")
            continue;
        $result[size($result)] = $a;
    }
    return $result;
}

// ?e?e?L?X?g?t?B?[???h????w?????I?u?W?F?N?g????????A?J??????????ÑÑ??????
proc int getLoopCountFromTextfield(){
    string $t = `textField -q -tx RITAI_FIELD`;
    string $c = `textField -q -tx PATHCURVE_FIELD`;
    string $direction = "Z";
    if(`checkBox -q -value TRACK_LOOP_DIRECTION_CHECKBOX`)
        $direction = "X";
    return getLoopCount($t, $c, $direction, 0.01);
}

// ???ÑÑ?I?u?W?F?N?g??p?X??J?[?u?A???Ñå??I?t?Z?b?g??^?????A???ÑÑ?p?[?c?????????????????
proc int getLoopCount(string $track, string $curve, string $direction, float $offset){
    float $bbox[] = `exactWorldBoundingBox $track`;
    // X????
    float $len = abs($bbox[3] - $bbox[0]) + $offset;
    if($direction == "Z")
        $len = abs($bbox[5] - $bbox[2]) + $offset;
    // ?J?[?u????????èÔ
    float $curveLen = `arclen $curve`;
    int $res = ($curveLen / $len) + 0; // TODO: 1????????????????+1
    print $res;
    return $res;
}

// ?e?L?X?g?t?B?[???h??w???????ÑÑ?J?[?u????A?J?[?u????Ë\???????ÑÑ?????????
proc duplicateCaterpillerFromUI ( ){
    float $num = getLoopCountFromTextfield(); 
    string $direction = "Z";
    if(`checkBox -q -value TRACK_LOOP_DIRECTION_CHECKBOX`)
        $direction = "X";
    string $track = `textField -q -tx RITAI_FIELD`;
    float $offset = 0.001;
    duplicateCaterpiller($track, $num, $offset, $direction);
}

// ???ÑÑ??w???R?s?[????
global proc duplicateCaterpiller(string $track, int $num, float $offset, string $direction){
    float $bbox[] = `xform -q -bb -ws $track`;
    float $len = 0;
    if($direction == "X") 
        $len = abs($bbox[3] - $bbox[0]) + $offset;
    else if($direction == "Z")
        $len = abs($bbox[5] - $bbox[2]) + $offset;
    else
        $len = abs($bbox[4] - $bbox[1]) + $offset;

    print ($bbox);
    print ("\n");
    print($offset + "\n");
    
    int $i;
    select -r $track;
    string $parent[];
    appendStringArray($parent, {$track}, 1); // ?e?z???????l??$track
    for ($i = 0; $i < $num; $i++){
        $_childs = `duplicate -rr`;
        if($direction == "X")
            move -r -os -wd -x $len;
        else if($direction == "Z")
            move -r -os -wd -z $len;
        else
            move -r -os -wd -y $len;
        select -add $parent;
        parent;
        $parent = $_childs;
    }
    setLastJointField($parent[0]);
}

// ?J?n?W???C???g?????W???C???g???J?[?u?????X?v???C??IK?n???h??????
global proc attachIKsprineHandleToCurve(){
    select -r `getFirstJointField` ;
    select -add `getLastJointField` ;
    select -add `textField -q -tx PATHCURVE_FIELD` ;
    ikHandle -sol ikSplineSolver -ccv false -roc false -pcv false;
}

// ?J?n?W???C???g???J?[?u????????[?V?????p?X?????A?^?b?`
global proc attachPathAnimationToCurve(){
    select -r `getFirstJointField` ;
    select -add `textField -q -tx PATHCURVE_FIELD` ;
    pathAnimation -fractionMode true -follow true -followAxis x -upAxis y -worldUpType "vector" -worldUpVector 0 1 0 -inverseUp false -inverseFront false -bank false -startTimeU `playbackOptions -query -minTime` -endTimeU  `playbackOptions -query -maxTime`;
}

// ?w??J?[?u??CV??????A??????????????CV??C???f?b?N?X??????
proc float[] getUnderCurvePoints(){
    $c = "nurbsCircle1";
    select -r $c;
    int $spans = getAttr($c + ".spans");
    int $i;
    float $sum = 0;
    float $heights[]; // ?eCV??Y???W?l
    for($i = 0;$i < $spans;$i++){
        float $_pos[] = pointPosition($c + ".cv[" + $i + "]");
        $sum += $_pos[1]; // Y???W
        $heights[$i] = $_pos[1];
    }
    float $avg = ($sum / $spans);
    float $results[];
    int $j = 0;
    for($i = 0;$i < $spans; $i++){
        if($heights[$i] < $avg){
            $results[$j] = $i;
            $j++;
        }
    }
    return $results;
}


// ?]??????i?]????Q???????j?n?`??_????
proc string getTerrainPointUnderWheel(){
    $terrain = "terrain";
    $wheelPivot = `textField -q -tx WHEEL1_FIELD`;
    float $px = `getAttr ($wheelPivot + ".tx")`;
    float $pz = `getAttr ($wheelPivot + ".tz")`;
    vector $pvec = <<$px, 0, $pz>>;
    string $_vertexes[] = `polyListComponentConversion -tv $terrain`;
    string $resultVertex; // ???????_
    float $minLen = -1; // ???????????
    for($vtx in `filterExpand -sm 31 $_vertexes`){
        float $_coordinates[] = pointPosition($vtx);
        float $tX = $_coordinates[0];
        float $tZ = $_coordinates[2];
        vector $tvec = <<$tX, 0, $tZ>>;
        float $len = mag($pvec - $tvec); // ??_??????
        if($len < $minLen || $minLen < 0){
            $minLen = $len;
            $resultVertex = $vtx;
        }
    }
    print ($resultVertex + "\n");
    select $resultVertex;
    return $resultVertex;
}
// ?]??????n????????u??
proc setWheelHeightOverTerrain(){
    $terrain = "terrain";
    $radius = 0.76315;
    $vtx = getTerrainPointUnderWheel();
    $moveIK = "ikHandle2";
    $_vtxPos = pointPosition($vtx);
    float $vy = $_vtxPos[1];
    print $vy;
    print "\n";
    float $py = $vy + $radius;
    print $py;
    print "\n";
    float $diffY = $py - `getAttr($moveIK + ".ty")`;
    print $diffY;
    print "\n";
    select -r $moveIK;
    move -r 0 $diffY 0;
    
}

// ????_??????????n?`????_???????[?e?B???e?B
proc string getTerrainPointUnder(string $pivot, string $terrain){
    float $px = `getAttr ($pivot + ".tx")`;
    float $pz = `getAttr ($pivot + ".tz")`;
    vector $pvec = <<$px, 0, $pz>>;
    string $_vertexes[] = `polyListComponentConversion -tv $terrain`;
    string $resultVertex; // ???????_
    float $minLen = -1; // ???????????
    for($vtx in `filterExpand -sm 31 $_vertexes`){
        float $_coordinates[] = pointPosition($vtx);
        float $tX = $_coordinates[0];
        float $tZ = $_coordinates[2];
        vector $tvec = <<$tX, 0, $tZ>>;
        float $len = mag($pvec - $tvec); // ??_??????
        if($len < $minLen || $minLen < 0){
            $minLen = $len;
            $resultVertex = $vtx;
        }
    }
    return $resultVertex;
}

// ????_????????n?`????_???????[?e?B???e?B
proc string getClosetTerrainPointUnder(string $pivot, string $terrain){
    $_pos = `xform -q -ws -t $pivot`;
    float $pX = $_pos[0];
    float $pY = $_pos[1];
    float $pZ = $_pos[2];
    vector $pVec = <<$pX, $pY, $pZ>>;
    string $_vertexes[] = `polyListComponentConversion -tv $terrain`;
    string $resultVertex; // ???????_
    float $minLen = -1; // ???????????
    for($vtx in `filterExpand -sm 31 $_vertexes`){
        float $_coordinates[] = pointPosition($vtx);
        float $tY = $_coordinates[1];
        float $tX = $_coordinates[0];
        float $tZ = $_coordinates[2];
        vector $tvec = <<$tX, $tY, $tZ>>;
        float $len = mag($pVec - $tvec); // ??_??????
        if($len < $minLen || $minLen < 0){
            $minLen = $len;
            $resultVertex = $vtx;
        }
    }
    return $resultVertex;
}

// ????~??n?`?????????z?u?????[?e?B???e?B
proc setCylinderHeightOverTerrain(string $cylinder, float $radius, string $terrain){
    $vtx = getTerrainPointUnder($cylinder, $terrain);
    $_vtxPos = pointPosition($vtx);
    float $vy = $_vtxPos[1];
    float $py = $vy + $radius;
    float $diffY = $py - `getAttr($cylinder + ".ty")`;
    select -r $cylinder;
    move -r 0 $diffY 0;
}
// ?~????n?`???????z?u???????e?X?g
// ??????~??????a?????[??????A??????_?????????????_????C??t????K?v?????????????A??????????????p??????????u
global proc testSetCylinders(int $n, float $radius, string  $terrain){
    for($i = 1; $i <= $n; $i++){
        string $target = "testCylinder" + $i;
        print ($target + "move\n");
        setCylinderHeightOverTerrain($target, $radius, $terrain);
    }
}

// ?n?`??v???[??????W??????f?R?{?R?????
proc createTerrainRoughness(float $offset){
    $offset = 0.5;
    $terrain = `textField -q -tx TERRAIN_FIELD`;
    string $vtx;
    string $_vertexes[] = `polyListComponentConversion -tv $terrain`;
    for($vtx in `filterExpand -sm 31 $_vertexes`){
        float $_coordinates[] = pointPosition($vtx);
        float $vX = $_coordinates[0];
        float $vZ = $_coordinates[2];
        float $randY = rand(-$offset, $offset);
        move $vX $randY $vZ $vtx;
        
    }
}


// ????V?????_?[???p?x?????Á∑?????V?????_?[?[?????[???h???W??????????z?u?????????A?[??X???W???o???B
// y: ?s?{?b?g????????Y?i???É†l)
// angle: degree. 0~360
// return: ?s?{?b?g????????X?i?????t???j
proc float calcSuspensionX(float $y, float $angle){
    $angle = $angle % 360;
    $l = $y / sind($angle);
    if($angle >= 180){
       $l = -$l; 
    }
    float $x = $l * cosd($angle);
    if(90 <= $angle && $angle <= 270){
        $x = -$x;
    }
    return $x;
}

// ????I?u?W?F?N?g??o?E???f?B???O?{?b?N?X????????_???èÔ????
proc string[] getTerrainPointUnder(string $obj, string $terrain){
    $bb = exactWorldBoundingBox($obj);
    $minX = $bb[0];
    $maxX = $bb[3];
    $minZ = $bb[2];
    $maxZ = $bb[5];
    string $_vertexes[] = `polyListComponentConversion -tv $terrain`;
    string $resultVertexes[]; // ??????_
    int $i = 0;
    for($vtx in `filterExpand -sm 31 $_vertexes`){
        float $_coordinates[] = pointPosition($vtx);
        float $tX = $_coordinates[0];
        float $tZ = $_coordinates[2];
        
        if($minX <= $tX && $tX <= $maxX && $minZ <= $tZ && $tZ <= $maxZ){
            $resultVertexes[$i] = $vtx;
            $i += 1;
        }
    }
    return $resultVertexes;
}

// ???i?~???j??n??????u?????? YZ????????

proc landWheelOnGround(){
    $wheelPivot = `textField -q -tx WHEEL1_FIELD`;
    $terrain = `textField -q -tx TERRAIN_FIELD`;
    float $radius = `textField -q -tx WHEEL_RADIUS_FIELD`;
    string $vertexes[] = getTerrainPointUnder($wheelPivot, $terrain);
    $_pos = `xform -q -ws -t $wheelPivot`;
    //float $pY = getAttr(($wheelPivot + ".ty"));
    //float $pZ = getAttr(($wheelPivot + ".tz"));
    float $pY = $_pos[1];
    float $pZ = $_pos[2];
    
    float $minHypot = -1;
    float $minY, $minZ;
    string $minV;
    for($vtx in $vertexes){
        float $_coordinates[] = pointPosition($vtx);
        float $tY = $_coordinates[1];
        float $tZ = $_coordinates[2];
        float $hyp = hypot($pY - $tY, $pZ - $tZ);
        
        if($minHypot == -1 || $hyp < $minHypot){
            $minHypot = $hyp;
            $minY = $tY;
            $minZ = $tZ;
            $minV = $vtx;
        }
    }
    
    select $minV;
    print( "" + $minY + "," + $minZ + "\n");
    
    float $resultY = sqrt((pow($radius, 2) - pow($pZ - $minZ, 2)));
    print("" + $resultY + "\n");
    float $resultWorldY = ($minY + $resultY);
    print("???????????[???hY?F" + $resultWorldY + "\n");
    
    select -r $wheelPivot;
    move -ws -y $resultWorldY;
}


// YZ?????????????~???????????n?`????_????
proc string getTerrainPointUnder(string $cylinder, string $terrain){
    $_pos = `xform -q -ws -t $cylinder`;
    float $pY = $_pos[1];
    float $pZ = $_pos[2];
    string $_vertexes[] = `polyListComponentConversion -tv $terrain`;
    string $resultVertex; // ???????_
    float $minLen = -1; // ???????????
    for($vtx in `filterExpand -sm 31 $_vertexes`){
        float $_coordinates[] = pointPosition($vtx);
        float $tY = $_coordinates[1];
        float $tZ = $_coordinates[2];
        float $hyp = hypot($pY - $tY, $pZ - $tZ);
        if($minLen == -1 || $minLen > $hyp){
            $minLen = $hyp;
            $resultVertex = $vtx;
        }
    }
    return $resultVertex;
}

// ????????IK?n???h???????????????n????u??????J????
proc adjustIkOnTerrain(){
    $wheelPivot = `textField -q -tx WHEEL1_FIELD`;
    $terrain = `textField -q -tx TERRAIN_FIELD`;
    float $radius = `textField -q -tx WHEEL_RADIUS_FIELD`;
    
    adjustIkOnTerrainRecursive(-1, 1, $radius, $wheelPivot, $terrain, 0);
}

// GUI??w?????]???IK?i?????j??????????n?`???????
proc adjustMovableWheelsOnTerrain(){
    $_text = `textField -q -tx WHEELS_FIELD`;
    $wheels = getTextFieldObjects($_text);
    $terrain = `textField -q -tx TERRAIN_FIELD`;
    float $radius = `textField -q -tx WHEEL_RADIUS_FIELD`;
    
    for($w in $wheels){
        adjustIkOnTerrainRecursive(-1, 1, $radius, $w, $terrain, 0);
    }
}

// ?e?]????u??L?[????
proc setKeyWheels(){
    $_text = `textField -q -tx WHEELS_FIELD`;
    $wheels = getTextFieldObjects($_text);

    for($w in $wheels){
        select -r $w;
        if( `getAttr -k ($w + ".tx")`||`getAttr -channelBox ($w + ".tx")` )
            setKeyframe ($w + ".tx");
        if( `getAttr -k ($w + ".ty")`||`getAttr -channelBox ($w + ".ty")` )
            setKeyframe ($w + ".ty");
        if( `getAttr -k ($w + ".tz")`||`getAttr -channelBox ($w + ".tz")` )
        setKeyframe ($w + ".tz");
    }
}

// IK???????????????????????????A???
proc adjustIkOnTerrainRecursive(int $isUp, float $dist, float $radius, string $Ik, string $terrain, int $count){
    // ?w???ÉO???????s??
    select -r $Ik;
    if($isUp == true){
        move -r -y $dist;
    }else if($isUp == false){
        move -r -y (-$dist);
    }
    if($dist < 0.001){ // ?É’??????????????????I??
        return;
    }
    // ?n????????_???èÔ
    string $vtx = getClosetTerrainPointUnder($Ik, $terrain);
    $_pos = `xform -q -ws -t $Ik`;
    $_coordinates =  pointPosition($vtx);
    $pvec = <<(float)$_pos[0], (float)$_pos[1],(float)$_pos[2]>>;
    $tvec = << (float)$_coordinates[0],(float)$_coordinates[1], (float)$_coordinates[2] >>;
    $len = mag($pvec - $tvec);
    // ?n????G???????????ÉO?A????????????????
    $nextIsUp = false;
    if($radius >= $len){
        $nextIsUp = true;
    }
    // ??????????????????????????????????????????
    if($isUp != $nextIsUp){
        $dist *= 0.1;
    }
    // ??????????[?v???????????????????I??I??
    if($count > 100){
        return;
    }
    $count += 1;
    adjustIkOnTerrainRecursive($nextIsUp, $dist, $radius, $Ik, $terrain, $count);
}

// ?p?X??J?[?u??]???Y????
proc editPathCurveFromWheels(){
   
    $ws = `textField -q -tx WHEELS_FIELD`;
    $dws = `textField -q -tx DRIVE_WHEELS_FIELD`;
    $fws = `textField -q -tx FIXED_WHEELS_FIELD`;
    
    float $radius = `textField -q -tx WHEEL_RADIUS_FIELD`; // ?]?????a
    float $fwRadius = `textField -q -tx DRIVE_WHEEL_RADIUS_FIELD`; // ?]?????a
    

    vector $points[];    // CV
    int $size = 0;
    
    $wheels = getTextFieldObjects($ws);
    for($w in $wheels){
        print $w;
        $_pos = `xform -q -ws -t $w`;
        float $x = $_pos[0];
        float $y = $_pos[1] - $radius;
        float $z = $_pos[2];
        
        $points[$size] = << $x, $y, $z >>;
        $size++;
    }
    
    
    $driveWheels = getTextFieldObjects($dws);
    print($driveWheels); //DEBUG
    $dwRadius = $radius;
    vector $_dw[];
    for($w in $driveWheels){
        print($w); print("\n");
        $_pos = `xform -q -ws -t $w`;
        float $x = $_pos[0];
        float $y = $_pos[1];
        float $z = $_pos[2];
        
        $_dw[size($_dw)] = << $x, $y, $z >>;
    }
    
    print("\n_dwAdd\n"); // DEBUG
        
    // ?????O??????????????CV??p???????
    vector $dw_f[], $dw_r[];
    $_dw = bubbleSortVector($_dw, "z");
    $r45 = 0.70710678118 * $dwRadius; // 45?x??_
    $_dw_first = $_dw[0]; // ?O?????
    $dw_f[size($dw_f)] = << $_dw_first.x, ($_dw_first.y - $dwRadius), $_dw_first.z >>; // ??
    $dw_f[size($dw_f)] = << $_dw_first.x, ($_dw_first.y - $r45), ($_dw_first.z - $r45) >>;
    $dw_f[size($dw_f)] = << $_dw_first.x, $_dw_first.y, ($_dw_first.z - $dwRadius) >>; // ?O
    $dw_f[size($dw_f)] = << $_dw_first.x, ($_dw_first.y + $r45), ($_dw_first.z - $r45) >>;
    $dw_f[size($dw_f)] = << $_dw_first.x, ($_dw_first.y + $dwRadius), $_dw_first.z >>; // ??
    $_dw_last = $_dw[size($_dw) - 1]; // ???????
    $dw_r[size($dw_r)] = << $_dw_last.x, ($_dw_last.y + $dwRadius), $_dw_last.z >>; // ??
    $dw_r[size($dw_r)] = << $_dw_last.x, ($_dw_last.y + $r45), ($_dw_last.z + $r45) >>; // 
    $dw_r[size($dw_r)] = << $_dw_last.x, $_dw_last.y, ($_dw_last.z + $dwRadius) >>; // ???
    $dw_r[size($dw_r)] = << $_dw_last.x, ($_dw_last.y - $r45), ($_dw_last.z + $r45) >>; // 
    $dw_r[size($dw_r)] = << $_dw_last.x, ($_dw_last.y - $dwRadius), $_dw_last.z >>; // ??
    $_dw = {};
    
    print("_dw  sorted\n");
    
    // ??????
    for($w in getTextFieldObjects($fws)){
        $_pos = `xform -q -ws -t $w`;
        float $x = $_pos[0];
        float $y = $_pos[1] + $fwRadius;
        float $z = $_pos[2];
        
        $_dw[size($_dw)] = << $x, $y, $z>>;
    }
    
    print($_dw);
    print("\nfixedWheels added _dw\n"); // DEBUG
   
    
    // Sort
    $_dw = bubbleSortVector($_dw, "z");
    $points = bubbleSortVector($points, "z");
    $points = reverseArray($points);
    
    // append
    for($cv in $dw_f)
        $points[size($points)] = $cv;
    for($cv in $_dw)
        $points[size($points)] = $cv;
    for($cv in $dw_r)
        $points[size($points)] = $cv;
    
    // ?J?[?u????
    string $curve = "none";
    for($cv in $points){
        $x = $cv.x;
        $y = $cv.y;
        $z = $cv.z;
        if($curve == "none"){
            $curve = `curve -d 1 -p $x $y $z`;
        }else{
            curve -a -p $x $y $z $curve;
        }
    }
    rename $curve "trackPathCurve";
}

// ???????p?X??J?[?u???u?????v?u???r???h?v?u?g??v????
proc rebuildPathCurve(){
    float $scale = 1.05;
    string $curve = `textField -q -tx PATHCURVE_FIELD`;
    // Pivot?????
    float $curveCenter[] = getCurveCenter($curve);
    print "PIVOT\n";
    print $curveCenter;
    print ("\n");
    float $cx = $curveCenter[0];
    float $cy = $curveCenter[1];
    float $cz = $curveCenter[2];
    
    move -a $cx $cy $cz ($curve+".scalePivot") ($curve+".rotatePivot");
    
    closeCurve -ch 1 -ps 1 -rpo 1 -bb 0.5 -bki 0 -p 0.1 $curve;
    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 2 -kcp 1 -kep 1 -kt 0 -s 18 -d 2 -tol 1e-06 $curve;
    select $curve;
    scale -r $scale ;
}

// ???ÑÑ?J?[?u??s?{?b?g????????A???ÑÑ???W???C???g?????????????
proc alignPathAndTrack(){
    string $curve = `textField -q -tx PATHCURVE_FIELD`;
    string $startJoint = `textField -q -tx RITAI_FIELD`;
    
    select -r $curve;
    CenterPivot;
    xform -cpc;
    
    float $pivot[] = getAttr($curve + ".scalePivot");
    move -ws -a $pivot[0] $pivot[1] $pivot[2] $startJoint;
    
}



// ?x?N?^?[?z???\?[?g
proc vector[] bubbleSortVector(vector $v[], string $sortval){
    $changed = true;
    $s = size($v);
    while($changed){
        $changed = false;
        for($i = 0; $i < $s - 1; $i++){
            $bool = false;
            $va = $v[$i];
            $vb = $v[$i + 1];
            switch($sortval){
                case "x":
                    $bool = $va.x > $vb.x;
                    break;
                case "y":
                    $bool = $va.y > $vb.y;
                    break;
                case "z":
                    $bool = $va.z > $vb.z;
                    break;
            }
            if($bool){
                // ??????
                $v[$i] = $vb;
                $v[$i + 1] = $va;
                $changed = true;
            }
        }
    }
    return $v;
}

// ?J?[?u????S???èÔ
proc float[] getCurveCenter(string $curve){
    float $spans = getAttr($curve + ".spans");
    float $ax, $ay, $az;
    for($i = 0; $i < $spans; $i++){
        float $t[] = getAttr($curve + ".cv[" + $i + "]");
        $ax += $t[0];
        $ay += $t[1];
        $az += $t[2];
    }
    $ax /= $spans;
    $ay /= $spans;
    $az /= $spans;
    return ({ $ax, $ay, $az });
}

// ?z?????o?[?X
proc vector[] reverseArray(vector $v[]){
    vector $r[];
    int $size = size($v);
    for($i = 0; $i < $size; $i++){
        $r[$i] = $v[$size - 1 - $i];
    }
    return $r;
}

createCatToolWindow;